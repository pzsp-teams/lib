{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Teams API wrapper Lib","text":"<p>High-level Go (Golang) library that simplifies interaction with Microsoft Graph API. Provides abstraction over operations related to Teams, Channels, and Chats, adding a layer of automatic caching and name resolution.</p>"},{"location":"#key-features","title":"\ud83d\ude80 Key Features","text":"<ul> <li>Simplified Authentication: Built-in MSAL token support.</li> <li>Intelligent Cache: Automatic mapping of team names to IDs (e.g., \"DevOps Team\" -&gt; <code>UUID</code>), reducing API queries.</li> <li>Facade Architecture: One main <code>Client</code> providing access to all services (<code>Teams</code>, <code>Channels</code>, <code>Chats</code>).</li> <li>Type Safety: All operations return strongly typed models.</li> </ul>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<pre><code>go get (https://github.com/pzsp-teams/lib)\n</code></pre>"},{"location":"#architecture-concepts","title":"\ud83d\udee0\ufe0f Architecture &amp; Concepts","text":"<p>The library uses a Facade Pattern. The Client struct aggregates domain-specific services:</p> <ul> <li>client.Teams: Manage teams lifecycles and members.</li> <li>client.Channels: Manage standard and private channels.</li> <li>client.Chats: Handle messages and chat members.</li> </ul>"},{"location":"#the-reference-concept","title":"The \"Reference\" concept","text":"<p>Many methods accept a <code>_Ref</code> argument. This allows you to pass:</p> <ul> <li>UUID</li> <li>Display Name (email for UserRefs) - this provides convenient usage in interactive applications.   Library will automatically resolve refs to IDs.</li> </ul>"},{"location":"#quick-start","title":"\ud83d\udcbb Quick Start","text":"<p>Full example usage is showcased HERE Here is a simple example of how to initialize the client and list the current user's teams.</p>"},{"location":"#1-client-init","title":"1. Client init","text":"<pre><code>import (\n    \"context\"\n    \"time\"\n    \"[github.com/pzsp-teams/lib](https://github.com/pzsp-teams/lib)\"\n    \"[github.com/pzsp-teams/lib/config](https://github.com/pzsp-teams/lib/config)\"\n)\n\nfunc main() {\n    ctx := context.Background()\n\n    // Auth config (Azure AD)\n    authCfg := &amp;config.AuthConfig{\n        ClientID:   \"your-client-id\",\n        Tenant:     \"your-tenant-id\",\n        Email:      \"your-email\",\n        Scopes:     []string{\"[https://graph.microsoft.com/.default](https://graph.microsoft.com/.default)\"},\n        AuthMethod: \"DEVICE_CODE\", // Or \"INTERACTIVE\"\n    }\n\n    // Cache config\n    cacheCfg := &amp;config.CacheConfig{\n        Mode:     config.CacheAsync,\n        Provider: config.CacheProviderJSONFile, // Local file cache\n    }\n\n    // Client init\n    client, err := lib.NewClient(ctx, authCfg, nil, cacheCfg)\n    if err != nil {\n        panic(err)\n    }\n    defer lib.Close() // Important if using cache\n}\n</code></pre>"},{"location":"#2-example-usage","title":"2. Example usage","text":"<pre><code>// List joined teams\nteams, _ := client.Teams.ListMyJoined(ctx)\nfor _, t := range teams {\n    fmt.Printf(\"Team: %s (ID: %s)\\n\", t.DisplayName, t.ID)\n}\n\n// Create a new team\nnewTeam, _ := client.Teams.CreateViaGroup(ctx, \"Project Alpha\", \"project-alpha\", \"public\")\n</code></pre>"},{"location":"#authentication","title":"Authentication","text":"<p>The library uses <code>config.AuthConfig</code> to establish the connection.Ensure your Azure App Registration has the necessary API Permissions (e.g., <code>Team.ReadBasic.All</code>, <code>Channel.ReadBasic.All</code>) granted in the Azure Portal. Complete list of scopes required by all functions is available HERE</p> <p>There are two available ways to authenticate:</p> <ul> <li>INTERACTIVE - log in window will automatically be opened within your browser.</li> <li>DEVICE CODE - library will provide you the URL and code, which need to be manually opened with browser of your choice.</li> </ul>"},{"location":"#cache","title":"Cache","text":"<p>If enabled, stores metadata and non-sensitive mappings, (e.g., <code>TeamRef</code> -&gt; <code>UUID</code>) to provide efficient reference resolution.</p> <p></p>"},{"location":"#important","title":"\u26a0\ufe0f Important:","text":"<p>Because the cache might run background goroutines to keep data fresh, you must call lib.Close() when your application shuts down. This ensures all background operations complete and prevents memory leaks or race conditions.</p> <pre><code>defer lib.Close()\n</code></pre>"},{"location":"channels/","title":"Channels","text":""},{"location":"channels/#channels","title":"channels","text":"<pre><code>import \"github.com/pzsp-teams/lib/channels\"\n</code></pre> <p>Package channels provides various channel-related operations. It abstracts the underlying Microsoft Graph API calls. Package provides two services implementations - one with cache and one without cache. Both can be instantiated and used interchangeably. If cache is enabled, the service will use a caching layer to store and retrieve channel/member references, improving performance and reducing API calls. Concepts:</p> <ul> <li>Channels belong to teams.</li> <li>Channels can be standard or private.</li> <li>Users are identified by userID or email.</li> <li>Some operations require messageID - these can be obtained via ListMessages.</li> <li>ChannelRef is a reference (display name or ID) to a channel used in method parameters.</li> <li>If teamRef or channelRef is a display and is not unique, an ambiguity error is returned.</li> <li>The authenticated user (derived from MSAL) is the one making the API calls (appropriate scopes must be granted).</li> </ul> <p>If an async cached service is used, call Wait() to ensure all background cache updates are finished.</p>"},{"location":"channels/#index","title":"Index","text":"<ul> <li>type Service</li> <li>func NewService(ops channelOps, tr resolver.TeamResolver, cr resolver.ChannelResolver) Service</li> </ul>"},{"location":"channels/#type-service","title":"type Service","text":"<p>Service defines the interface for channel-related operations. It includes methods for managing channels, members, messages, and more.</p> <pre><code>type Service interface {\n    // ListChannels returns all channels in a team.\n    ListChannels(ctx context.Context, teamRef string) ([]*models.Channel, error)\n\n    // Get retrieves a specific channel by its reference (ID or display name) within a team.\n    Get(ctx context.Context, teamRef, channelRef string) (*models.Channel, error)\n\n    // CreateStandardChannel creates a standard channel within a team.\n    // Standard channels are open to all team members.\n    CreateStandardChannel(ctx context.Context, teamRef, name string) (*models.Channel, error)\n\n    // CreatePrivateChannel creates a private channel within a team.\n    // Private channels are restricted to specific members.\n    // At least one owner must be specified.\n    CreatePrivateChannel(ctx context.Context, teamRef, name string, memberRefs, ownerRefs []string) (*models.Channel, error)\n\n    // Delete removes a channel from a team.\n    Delete(ctx context.Context, teamRef, channelRef string) error\n\n    // SendMessage sends a message to a channel.\n    // Body parameter is the body of the message. It includes:\n    //   - Content: the text or html content of the message.\n    //   - ContentType: the type of content (text or html).\n    //   - Mentions: optional mentions to include in the message.\n    SendMessage(ctx context.Context, teamRef, channelRef string, body models.MessageBody) (*models.Message, error)\n\n    // SendReply sends a reply to a specific message in a channel.\n    // Body parameter is the body of the reply message. It includes:\n    //   - Content: the text or html content of the message.\n    //   - ContentType: the type of content (text or html).\n    //   - Mentions: optional mentions to include in the message.\n    SendReply(ctx context.Context, teamRef, channelRef, messageID string, body models.MessageBody) (*models.Message, error)\n\n    // ListMessages returns one page of messages in a channel.\n    //\n    // NextLink in the returned MessageCollection can be used to retrieve the next page of messages.\n    ListMessages(ctx context.Context, teamRef, channelRef string, opts *models.ListMessagesOptions, includeSystem bool, nextLink *string) (*models.MessageCollection, error)\n\n    // GetMessage retrieves a specific message from a channel by its ID.\n    GetMessage(ctx context.Context, teamRef, channelRef, messageID string) (*models.Message, error)\n\n    // ListReplies returns one page of replies to a specific message in a channel.\n    //\n    // NextLink in the returned MessageCollection can be used to retrieve the next page of replies.\n    ListReplies(ctx context.Context, teamRef, channelRef, messageID string, top *int32, includeSystem bool, nextLink *string) (*models.MessageCollection, error)\n\n    // GetReply retrieves a specific reply to a message in a channel by its ID.\n    GetReply(ctx context.Context, teamRef, channelRef, messageID, replyID string) (*models.Message, error)\n\n    // ListMembers returns all members of a channel.\n    ListMembers(ctx context.Context, teamRef, channelRef string) ([]*models.Member, error)\n\n    // AddMember adds a user to a channel.\n    AddMember(ctx context.Context, teamRef, channelRef, userRef string, isOwner bool) (*models.Member, error)\n\n    // UpdateMemberRoles updates the roles of a member in a channel.\n    UpdateMemberRoles(ctx context.Context, teamRef, channelRef, userRef string, isOwner bool) (*models.Member, error)\n\n    // RemoveMember removes a user from a channel.\n    RemoveMember(ctx context.Context, teamRef, channelRef, userRef string) error\n\n    // GetMentions resolves raw mention strings to Mention objects in the context of a channel. Raw mentions can be:\n    //   - Emails\n    //   - Channel (only the same channel as channelRef can be mentioned). It can be used by specifying \"channel\" or channel display name as raw mention.\n    //   - Team (only the parent team of the channel can be mentioned). It can be used by specifying \"team\" or team display name as raw mention.\n    //   - User IDs\n    GetMentions(ctx context.Context, teamRef, channelRef string, rawMentions []string) ([]models.Mention, error)\n}\n</code></pre> <p></p>"},{"location":"channels/#func-newservice","title":"func NewService","text":"<pre><code>func NewService(ops channelOps, tr resolver.TeamResolver, cr resolver.ChannelResolver) Service\n</code></pre> <p>NewService creates a new channels Service instance</p> <p>Generated by gomarkdoc</p>"},{"location":"chats/","title":"Chats","text":""},{"location":"chats/#chats","title":"chats","text":"<pre><code>import \"github.com/pzsp-teams/lib/chats\"\n</code></pre> <p>Package chats provides various chat-related operations. It abstracts the underlying Microsoft Graph API calls. Package provides two services implementations - one with cache and one without cache. Both can be instantiated and used interchangeably. If cache is enabled, the service will use a caching layer to store and retrieve chat/member references, improving performance and reducing API calls. Concepts:</p> <ul> <li>Chats are either one-on-one or group chats.</li> <li>Users are identified by userID or email.</li> <li>Some operations require messageID - these can be obtained via ListMessages.</li> <li>ChatRef and GroupChatRef are references to chats used in method parameters.</li> <li>If chatRef is a topic and is not unique, an ambiguity error is returned.</li> <li>The authenticated user (derived from MSAL) is the one making the API calls (appropriate scopes must be granted).</li> </ul> <p>If an async cached service is used, call Wait() to ensure all background cache updates are finished.</p>"},{"location":"chats/#index","title":"Index","text":"<ul> <li>type ChatRef</li> <li>type GroupChatRef</li> <li>type OneOnOneChatRef</li> <li>type Service</li> <li>func NewService(chatOps chatOps, cr resolver.ChatResolver) Service</li> </ul>"},{"location":"chats/#type-chatref","title":"type ChatRef","text":"<p>ChatRef is an interface representing a reference to a chat, which can be either a group chat or a one-on-one chat.</p> <pre><code>type ChatRef interface {\n    // contains filtered or unexported methods\n}\n</code></pre> <p></p>"},{"location":"chats/#type-groupchatref","title":"type GroupChatRef","text":"<p>GroupChatRef identifies a group chat. It may reference a chat by:</p> <ul> <li> <p>unique chatID</p> </li> <li> <p>chat topic</p> </li> </ul> <p>Note: Using chat topic may lead to ambiguities (which must be resolved manually) if multiple group chats share the same topic.</p> <pre><code>type GroupChatRef struct {\n    Ref string\n}\n</code></pre> <p></p>"},{"location":"chats/#type-oneononechatref","title":"type OneOnOneChatRef","text":"<p>OneOnOneChatRef identifies a one-on-one chat. It may reference a chat by:</p> <ul> <li> <p>unique chatID</p> </li> <li> <p>recipient's reference (userID, email)</p> </li> </ul> <p>Note: Chat must be established between the logged-in user and the recipient for resolution to succeed.</p> <pre><code>type OneOnOneChatRef struct {\n    Ref string\n}\n</code></pre> <p></p>"},{"location":"chats/#type-service","title":"type Service","text":"<p>Service defines the interface for chat-related operations. It includes methods for creating chats, managing members, sending messages, and more.</p> <pre><code>type Service interface {\n    // CreateOneOneOne creates a one-on-one chat with the given recipient.\n    // The authenticated user is automatically added to the chat.\n    CreateOneOnOne(ctx context.Context, recipientRef string) (*models.Chat, error)\n\n    // CreateGroup creates a group chat with the given recipients and topic.\n    // The authenticated user may be included by setting includeMe to true.\n    CreateGroup(ctx context.Context, recipientRefs []string, topic string, includeMe bool) (*models.Chat, error)\n\n    // AddMemberToGroupChat adds a user to a group chat.\n    AddMemberToGroupChat(ctx context.Context, chatRef GroupChatRef, userRef string) (*models.Member, error)\n\n    // RemoveMemberFromGroupChat removes a user from a group chat.\n    RemoveMemberFromGroupChat(ctx context.Context, chatRef GroupChatRef, userRef string) error\n\n    // ListGroupChatMembers returns all members of a group chat.\n    ListGroupChatMembers(ctx context.Context, chatRef GroupChatRef) ([]*models.Member, error)\n\n    // UpdateGroupChatTopic updates the topic of a group chat.\n    UpdateGroupChatTopic(ctx context.Context, chatRef GroupChatRef, topic string) (*models.Chat, error)\n\n    // ListMessages returns all messages in a chat.\n    //\n    // NextLink in the returned MessageCollection can be used to retrieve the next page of messages.\n    ListMessages(ctx context.Context, chatRef ChatRef, includeSystem bool, nextLink *string) (*models.MessageCollection, error)\n\n    // SendMessage sends a message to a chat.\n    // Body parameter is the body of the message. It includes:\n    //   - Content: the text or html content of the message.\n    //   - ContentType: the type of content (text or html).\n    //   - Mentions: optional mentions to include in the message.\n    SendMessage(ctx context.Context, chatRef ChatRef, body models.MessageBody) (*models.Message, error)\n\n    // DeleteMessage deletes a message from a chat. Action is reversible - soft delete is performed.\n    DeleteMessage(ctx context.Context, chatRef ChatRef, messageID string) error\n\n    // GetMessage retrieves a specific message from a chat by its ID.\n    GetMessage(ctx context.Context, chatRef ChatRef, messageID string) (*models.Message, error)\n\n    // ListChats returns all chats, optionally filtered by chat type.\n    ListChats(ctx context.Context, chatType *models.ChatType) ([]*models.Chat, error)\n\n    // ListAllMessages returns all messages in all chats within the specified time range. Top limits the number of messages returned.\n    //\n    // Note: This operation does not work in delegated permission mode.\n    ListAllMessages(ctx context.Context, startTime, endTime *time.Time, top *int32) ([]*models.Message, error)\n\n    // ListPinnedMessages returns all pinned messages in a chat.\n    ListPinnedMessages(ctx context.Context, chatRef ChatRef) ([]*models.Message, error)\n\n    // PinMessage pins a message in a chat.\n    PinMessage(ctx context.Context, chatRef ChatRef, messageID string) error\n\n    // UnpinMessage unpins a message in a chat.\n    UnpinMessage(ctx context.Context, chatRef ChatRef, pinnedMessageID string) error\n\n    // GetMentions resolves raw mention strings to Mention objects in the context of a chat. Raw mentions can be:\n    //   - Emails\n    //   - Everyone (for group chats)\n    //   - User IDs\n    GetMentions(ctx context.Context, chatRef ChatRef, rawMentions []string) ([]models.Mention, error)\n}\n</code></pre> <p></p>"},{"location":"chats/#func-newservice","title":"func NewService","text":"<pre><code>func NewService(chatOps chatOps, cr resolver.ChatResolver) Service\n</code></pre> <p>NewService creates a new instance of the chat service.</p> <p>Generated by gomarkdoc</p>"},{"location":"client/","title":"Client","text":""},{"location":"client/#lib","title":"lib","text":"<pre><code>import \"github.com/pzsp-teams/lib\"\n</code></pre> <p>Package lib acts as the primary entry point for the Microsoft Teams API client library. It adopts a Facade pattern, aggregating specialized services (Teams, Channels, Chats) into a single, cohesive Client.</p> <p>The package manages the complexity of:</p> <ul> <li>Authentication (via MSAL and Graph Token Providers).</li> <li>Dependency Injection (wiring APIs, Caches, and Resolvers).</li> <li>Caching strategies (transparently wrapping operations with caching layers).</li> </ul> <p>Usage: Initialize the Client using NewClient for a standard setup. Alternatively, if you need only specific services, use:</p> <ul> <li>NewTeamServiceFromGraphClient for Teams service.</li> <li>NewChannelServiceFromGraphClient for Channels service.</li> <li>NewChatServiceFromGraphClient for Chats service.</li> </ul> <p>Always ensure to call Close() upon application shutdown to flush any background cache operations.</p>"},{"location":"client/#index","title":"Index","text":"<ul> <li>func Close()</li> <li>func NewChannelServiceFromGraphClient(ctx context.Context, authCfg *config.AuthConfig, senderCfg *config.SenderConfig, cacheCfg *config.CacheConfig) (channels.Service, error)</li> <li>func NewChatServiceFromGraphClient(ctx context.Context, authCfg *config.AuthConfig, senderCfg *config.SenderConfig, cacheCfg *config.CacheConfig) (chats.Service, error)</li> <li>func NewTeamServiceFromGraphClient(ctx context.Context, authCfg *config.AuthConfig, senderCfg *config.SenderConfig, cacheCfg *config.CacheConfig) (teams.Service, error)</li> <li>type Client</li> <li>func NewClient(ctx context.Context, authCfg *config.AuthConfig, senderCfg *config.SenderConfig, cacheCfg *config.CacheConfig) (*Client, error)</li> <li>func NewClientFromGraphClient(graphClient *graph.GraphServiceClient, senderCfg *config.SenderConfig, cacheCfg *config.CacheConfig) (*Client, error)</li> </ul>"},{"location":"client/#func-close","title":"func Close","text":"<pre><code>func Close()\n</code></pre> <p>Close ensures a graceful shutdown of the library. It waits for any pending background operations (such as asynchronous cache updates) to complete before returning, preventing data loss or race conditions.</p> <p></p>"},{"location":"client/#func-newchannelservicefromgraphclient","title":"func NewChannelServiceFromGraphClient","text":"<pre><code>func NewChannelServiceFromGraphClient(ctx context.Context, authCfg *config.AuthConfig, senderCfg *config.SenderConfig, cacheCfg *config.CacheConfig) (channels.Service, error)\n</code></pre> <p>NewChannelServiceFromGraphClient creates a standalone service for Channel operations. Use this if you do not need the full Client wrapper and only want to interact with Channels.</p> <p></p>"},{"location":"client/#func-newchatservicefromgraphclient","title":"func NewChatServiceFromGraphClient","text":"<pre><code>func NewChatServiceFromGraphClient(ctx context.Context, authCfg *config.AuthConfig, senderCfg *config.SenderConfig, cacheCfg *config.CacheConfig) (chats.Service, error)\n</code></pre> <p>NewChatServiceFromGraphClient creates a standalone service for Chat operations. Use this if you do not need the full Client wrapper and only want to interact with Chats.</p> <p></p>"},{"location":"client/#func-newteamservicefromgraphclient","title":"func NewTeamServiceFromGraphClient","text":"<pre><code>func NewTeamServiceFromGraphClient(ctx context.Context, authCfg *config.AuthConfig, senderCfg *config.SenderConfig, cacheCfg *config.CacheConfig) (teams.Service, error)\n</code></pre> <p>NewTeamServiceFromGraphClient creates a standalone service for Team operations. Use this if you do not need the full Client wrapper and only want to interact with Teams.</p> <p></p>"},{"location":"client/#type-client","title":"type Client","text":"<p>Client is the central hub for interacting with the Microsoft Teams ecosystem. It aggregates access to specific domains: Channels, Teams, and Chats, hiding the complexity of underlying Graph API calls and caching mechanisms.</p> <pre><code>type Client struct {\n    Channels channels.Service\n    Teams    teams.Service\n    Chats    chats.Service\n}\n</code></pre> <p></p>"},{"location":"client/#func-newclient","title":"func NewClient","text":"<pre><code>func NewClient(ctx context.Context, authCfg *config.AuthConfig, senderCfg *config.SenderConfig, cacheCfg *config.CacheConfig) (*Client, error)\n</code></pre> <p>NewClient initializes a new Client instance with fully configured internal services. It handles the authentication handshake using the provided authCfg and sets up sending and caching behaviors based on senderCfg and cacheCfg.</p> <p></p>"},{"location":"client/#func-newclientfromgraphclient","title":"func NewClientFromGraphClient","text":"<pre><code>func NewClientFromGraphClient(graphClient *graph.GraphServiceClient, senderCfg *config.SenderConfig, cacheCfg *config.CacheConfig) (*Client, error)\n</code></pre> <p>NewClientFromGraphClient creates a Client using an existing, pre-configured GraphServiceClient. This is a separated exported constructor mainly for external testing purposes (via mocking Teams API by injection of GraphServiceClient).</p> <p>It wires up all internal dependencies, including API clients, caching layers, and entity resolvers (e.g., resolving team names to IDs).</p> <p>Generated by gomarkdoc</p>"},{"location":"config/","title":"Config","text":""},{"location":"config/#config","title":"config","text":"<pre><code>import \"github.com/pzsp-teams/lib/config\"\n</code></pre> <p>Package config holds configuration structs used across the application. Defined configs:</p> <ul> <li>AuthConfig: holds authentication configuration.</li> <li>SenderConfig: holds sender configuration.</li> <li>CacheConfig: holds caching configuration.</li> </ul>"},{"location":"config/#index","title":"Index","text":"<ul> <li>type AuthConfig</li> <li>type CacheConfig</li> <li>type CacheMode</li> <li>type CacheProvider</li> <li>type Method</li> <li>type SenderConfig</li> </ul>"},{"location":"config/#type-authconfig","title":"type AuthConfig","text":"<p>AuthConfig holds configuration for authentication. All fields are required - they are needed to acquire tokens via MSAL.</p> <pre><code>type AuthConfig struct {\n    ClientID   string\n    Tenant     string\n    Email      string\n    Scopes     []string\n    AuthMethod Method\n}\n</code></pre> <p></p>"},{"location":"config/#type-cacheconfig","title":"type CacheConfig","text":"<p>CacheConfig holds configuration for caching.</p> <pre><code>type CacheConfig struct {\n    Mode     CacheMode\n    Provider CacheProvider\n    Path     *string\n}\n</code></pre> <p></p>"},{"location":"config/#type-cachemode","title":"type CacheMode","text":"<p>CacheMode defines the caching strategy used by the application.</p> <pre><code>type CacheMode string\n</code></pre> <p></p> <pre><code>const (\n    // CacheDisabled indicates that caching is turned off.\n    CacheDisabled CacheMode = \"DISABLED\"\n\n    // CacheSync indicates that cache operations are performed synchronously.\n    CacheSync CacheMode = \"SYNC\"\n\n    // CacheAsync indicates that cache operations are performed asynchronously.\n    CacheAsync CacheMode = \"ASYNC\"\n)\n</code></pre> <p></p>"},{"location":"config/#type-cacheprovider","title":"type CacheProvider","text":"<p>CacheProvider defines the backend used for caching.</p> <pre><code>type CacheProvider string\n</code></pre> <p></p> <pre><code>const (\n    // CacheProviderJSONFile indicates that json-file cache is used.\n    CacheProviderJSONFile CacheProvider = \"JSON_FILE\"\n)\n</code></pre> <p></p>"},{"location":"config/#type-method","title":"type Method","text":"<p>Method defines the authentication flow used when acquiring tokens.</p> <pre><code>type Method string\n</code></pre> <p></p> <pre><code>const (\n    // Interactive opens a browser window for user authentication.\n    Interactive Method = \"INTERACTIVE\"\n\n    // DeviceCode prints a device code to the console and prompts the user to visit a URL to authenticate.\n    DeviceCode Method = \"DEVICE_CODE\"\n)\n</code></pre> <p></p>"},{"location":"config/#type-senderconfig","title":"type SenderConfig","text":"<p>SenderConfig defines configuration for the request sender which connects with the Microsoft Graph API. MaxRetryDelay and Timeout are in seconds.</p> <pre><code>type SenderConfig struct {\n    MaxRetries     int\n    NextRetryDelay int\n    Timeout        int\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"models/","title":"Models","text":""},{"location":"models/#models","title":"models","text":"<pre><code>import \"github.com/pzsp-teams/lib/models\"\n</code></pre> <p>Package models contains simplified Microsoft Teams domain types used by this library.</p>"},{"location":"models/#index","title":"Index","text":"<ul> <li>type Channel</li> <li>type Chat</li> <li>type ChatType</li> <li>type ListMessagesOptions</li> <li>type Member</li> <li>type Mention</li> <li>type MentionKind</li> <li>type Message</li> <li>type MessageBody</li> <li>type MessageCollection</li> <li>type MessageContentType</li> <li>type MessageFrom</li> <li>type Team</li> <li>type TeamUpdate</li> </ul>"},{"location":"models/#type-channel","title":"type Channel","text":"<p>Channel represents a Microsoft Teams channel.</p> <pre><code>type Channel struct {\n    ID        string\n    Name      string\n    IsGeneral bool\n}\n</code></pre> <p></p>"},{"location":"models/#type-chat","title":"type Chat","text":"<p>Chat represents a chat in Microsoft Teams.</p> <pre><code>type Chat struct {\n    ID       string\n    Type     ChatType\n    IsHidden bool\n    Topic    *string\n}\n</code></pre> <p></p>"},{"location":"models/#type-chattype","title":"type ChatType","text":"<p>ChatType represents the type of chat in Microsoft Teams. Type can be either one-on-one or group chat</p> <pre><code>type ChatType string\n</code></pre> <p></p> <pre><code>const (\n    // ChatTypeOneOnOne represents a one-on-one chat.\n    ChatTypeOneOnOne ChatType = \"one-on-one\"\n    // ChatTypeGroup represents a group chat.\n    ChatTypeGroup ChatType = \"group\"\n)\n</code></pre> <p></p>"},{"location":"models/#type-listmessagesoptions","title":"type ListMessagesOptions","text":"<p>ListMessagesOptions contains options for listing messages.</p> <pre><code>type ListMessagesOptions struct {\n    Top           *int32\n    ExpandReplies bool\n}\n</code></pre> <p></p>"},{"location":"models/#type-member","title":"type Member","text":"<p>Member represents a member of a Microsoft Teams channel, direct chat or team.</p> <pre><code>type Member struct {\n    ID          string\n    UserID      string\n    DisplayName string\n    Role        string\n    Email       string\n}\n</code></pre> <p></p>"},{"location":"models/#type-mention","title":"type Mention","text":"<p>Mention represents a mention in a Microsoft Teams message.</p> <pre><code>type Mention struct {\n    Kind     MentionKind\n    AtID     int32\n    Text     string\n    TargetID string\n}\n</code></pre> <p></p>"},{"location":"models/#type-mentionkind","title":"type MentionKind","text":"<p>MentionKind represents the kind of mention in a Microsoft Teams message.</p> <pre><code>type MentionKind string\n</code></pre> <p></p> <pre><code>const (\n    // MentionUser represents a user mention.\n    MentionUser MentionKind = \"user\"\n    // MentionChannel represents a channel mention.\n    MentionChannel MentionKind = \"channel\"\n    // MentionTeam represents a team mention.\n    MentionTeam MentionKind = \"team\"\n    // MentionEveryone represents an everyone mention - applicable to group chats only\n    MentionEveryone MentionKind = \"everyone\"\n)\n</code></pre> <p></p>"},{"location":"models/#type-message","title":"type Message","text":"<p>Message represents a Microsoft Teams chat message. It can be used in both chats and channels.</p> <pre><code>type Message struct {\n    ID              string\n    Content         string\n    ContentType     MessageContentType\n    CreatedDateTime time.Time\n    From            *MessageFrom\n    ReplyCount      int\n}\n</code></pre> <p></p>"},{"location":"models/#type-messagebody","title":"type MessageBody","text":"<p>MessageBody represents the body of a message in Microsoft Teams.</p> <pre><code>type MessageBody struct {\n    Content     string\n    ContentType MessageContentType\n    Mentions    []Mention\n}\n</code></pre> <p></p>"},{"location":"models/#type-messagecollection","title":"type MessageCollection","text":"<p>MessageCollection represents a collection of messages, potentially with a link to the next page of results.</p> <pre><code>type MessageCollection struct {\n    Messages []*Message\n    NextLink *string\n}\n</code></pre> <p></p>"},{"location":"models/#type-messagecontenttype","title":"type MessageContentType","text":"<p>MessageContentType represents the type of content in a Microsoft Teams message. It can be either text or HTML.</p> <pre><code>type MessageContentType string\n</code></pre> <p></p> <pre><code>const (\n    // MessageContentTypeText represents plain text content.\n    MessageContentTypeText MessageContentType = \"text\"\n    // MessageContentTypeHTML represents HTML content.\n    MessageContentTypeHTML MessageContentType = \"html\"\n)\n</code></pre> <p></p>"},{"location":"models/#type-messagefrom","title":"type MessageFrom","text":"<p>MessageFrom represents the sender of a message in Microsoft Teams.</p> <pre><code>type MessageFrom struct {\n    UserID      string\n    DisplayName string\n}\n</code></pre> <p></p>"},{"location":"models/#type-team","title":"type Team","text":"<p>Team represents a Microsoft Teams team.</p> <pre><code>type Team struct {\n    ID          string\n    DisplayName string\n    Description string\n    IsArchived  bool\n    Visibility  *string\n}\n</code></pre> <p></p>"},{"location":"models/#type-teamupdate","title":"type TeamUpdate","text":"<p>TeamUpdate represents the fields that can be updated for a Team.</p> <pre><code>type TeamUpdate struct {\n    DisplayName *string\n    Description *string\n    Visibility  *string\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"teams/","title":"Teams","text":""},{"location":"teams/#teams","title":"teams","text":"<pre><code>import \"github.com/pzsp-teams/lib/teams\"\n</code></pre> <p>Package teams provides team-related operations and abstracts the underlying Microsoft Graph API calls.</p> <p>The package exposes two interchangeable service implementations: one without cache and one with cache. When cache is enabled, the service stores and reuses team references (e.g. display name -&gt; team ID), reducing the number of resolver/API calls. The cache may be cleared on request errors.</p> <p>Concepts:</p> <ul> <li>teamRef is a team reference (ID or display name) used in method parameters.</li> <li>Operations are executed on behalf of the authenticated user (derived from MSAL); required scopes must be granted.</li> <li>Some operations accept a Graph patch object (msmodels.Team) for updates.</li> <li>Archived teams can be archived/unarchived via dedicated operations.</li> <li>Deleted teams can be restored using a deleted group ID.</li> </ul> <p>If an async cached service is used, call Wait() to ensure all background cache updates are finished.</p>"},{"location":"teams/#index","title":"Index","text":"<ul> <li>type Service</li> <li>func NewService(teamOps teamsOps, tr resolver.TeamResolver) Service</li> </ul>"},{"location":"teams/#type-service","title":"type Service","text":"<p>Service defines the interface for team-related operations. It includes methods for retrieving, creating, updating, archiving, unarchiving, deleting, and restoring teams.</p> <pre><code>type Service interface {\n    // Get retrieves a specific team by its reference (ID or display name).\n    Get(ctx context.Context, teamRef string) (*models.Team, error)\n\n    // ListMyJoined returns all teams the authenticated user has joined.\n    ListMyJoined(ctx context.Context) ([]*models.Team, error)\n\n    // CreateViaGroup creates a new team associated with a Microsoft 365 group.\n    CreateViaGroup(ctx context.Context, displayName, mailNickname, visibility string) (*models.Team, error)\n\n    // CreateFromTemplate creates a new team from a template.\n    CreateFromTemplate(ctx context.Context, displayName, description string, owners, members []string, visibility string, includeMe bool) (string, error)\n\n    // Archive archives a team, optionally making SharePoint read-only for members.\n    Archive(ctx context.Context, teamRef string, spoReadOnlyForMembers *bool) error\n\n    // Unarchive restores an archived team.\n    Unarchive(ctx context.Context, teamRef string) error\n\n    // Delete removes a team.\n    Delete(ctx context.Context, teamRef string) error\n\n    // RestoreDeleted restores a deleted team using the deleted group ID.\n    RestoreDeleted(ctx context.Context, deletedGroupID string) (string, error)\n\n    // ListMembers returns all members of a team.\n    ListMembers(ctx context.Context, teamRef string) ([]*models.Member, error)\n\n    // GetMember retrieves a specific member of a team by their member ID or user email.\n    GetMember(ctx context.Context, teamRef, userRef string) (*models.Member, error)\n\n    // AddMember adds a new member to a team.\n    AddMember(ctx context.Context, teamRef string, userRef string, isOwner bool) (*models.Member, error)\n\n    // RemoveMember removes a member from a team by their member ID or user email.\n    RemoveMember(ctx context.Context, teamRef, userRef string) error\n\n    // UpdateMemberRoles updates the roles of a team member (e.g., promote to owner or demote to member).\n    UpdateMemberRoles(ctx context.Context, teamRef, userRef string, isOwner bool) (*models.Member, error)\n\n    // UpdateTeam applies updates to a team using the provided TeamUpdate object.\n    UpdateTeam(ctx context.Context, teamRef string, update *models.TeamUpdate) (*models.Team, error)\n}\n</code></pre> <p></p>"},{"location":"teams/#func-newservice","title":"func NewService","text":"<pre><code>func NewService(teamOps teamsOps, tr resolver.TeamResolver) Service\n</code></pre> <p>NewService creates a new Service instance.</p> <p>Generated by gomarkdoc</p>"}]}